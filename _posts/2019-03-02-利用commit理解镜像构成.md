---
layout: post
title: "利用commit理解镜像构成"
date: 2019-03-02
excerpt: ""
tags: [docker]
comments: true
---

*注意：`docker commit`命令有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用它来定制镜像，定制镜像应该使用`dockerfile`来完成。*



​	镜像是多层存储，每一层是在前一层的基础上进行的修改，而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行的存储层。

​	现在让我们以定制一个web服务器为例子，来讲解镜像是如何构成的。

```shell
docker run --name webserver -d -p 80:80 nginx
```

​	这条命令会用nginx镜像启动一个容器，命名为webserver，并且映射了80端口，这样我们可以用浏览器去访问这个nginx服务器。

​	直接用浏览器访问的话，我们会看到默认的nginx欢迎页面。现在，假设我们非常不喜欢这个欢迎页面，我们希望改成“Hello, Docker”的文字，我们可以使用`docker exec`命令进入容器，修改其内容。

```shell
docker exec -it webserver bash
```

​	我们以交互式终端方式进入webserver容器，并执行了bash命令，也就是获得一个可操作的shell。

​	然后，我们用`<h1>Hello, Docker</h1>`覆盖了`/usr/share/nginx/html/index.html`的内容。现在我们刷新浏览器的话，会发现内容被改变了。

​	我们修改了容器的文件，也就是改动了容器的存储层。我们可通过`docker diff`命令看到具体的改动。

```shell
docker diff webserver
```

​	现在我们定制好了变化，我们希望能将其保存下来形成镜像。

​	要知道，当我们运行一个容器的时候（如果不适用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而Docker提供了一个`docker commit`命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。

​	docker commit的语法格式为：

```shell
docker commit [选项] <容器ID或容器名> [<仓库名>[:<标签>]]
```

​	我们可以用下面的命令将容器保存为镜像：

```shell
docker commit \
	--author "Harris" \
	--message "修改了默认网页" \
	webserver \
	nginx:v2
```

​	我们还可以用`docker history`具体查看镜像内的历史记录。

```shell
docker history nginx:v2
```

​	

**慎用docker commit**

​	使用docker commit命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。

​	首先，如果仔细观察之前的`docker diff webserver`的结果，你会发现除了真正想要修改的`/usr/share/nginx/html/index.html`文件外，由于命令的执行，还有很多文件被改动或添加了。这不仅仅是最简单的操作，如果是安装软件包、编译构建，那么会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。

​	此外，使用`docker commit`意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。虽然`docker diff`或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。

​	而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用`docker commit`制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所以删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。

