---
layout: post
title: "使用Docker镜像"
date: 2019-02-22
excerpt: ""
tags: [docker]
comments: true
---

​	Docker运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker会从镜像仓库下载该镜像。



- 获取镜像

  ```shell
  docker pull [选项] [Docker Registry地址[:端口号]/]仓库名[:标签]
  ```

  ​	具体的选项可以通过`docker pull --help`命令看到，这里我们说一下镜像名称的格式：

  - Docker镜像仓库地址：地址格式一般是`<域名/IP>[:端口号]`。默认地址是Docker Hub。
  - 仓库名：仓库名是两段式名称，即`<用户名>/<软件名>`。对于Docker Hub，如果不给出用户名，则默认为`library`，也就是官方镜像。

  举个栗子：

  ```shell
  docker pull ubuntu:16.04
  ```

  ​	上面的命令中没有给出Docker镜像仓库地址，因此将会从Docker Hub获取镜像。而镜像名是ubuntu:16.04，因此将会获取官方镜像library/ubuntu仓库中的标签为16.04的镜像。

  ​	从下载过程可以看到我们之前提到的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的ID的前12位。并且下载结束后，给出该镜像完整的sha256的摘要，以确保下载一致性。

- 列出镜像

  ​	想要列出已经下载下来的镜像，可以使用`docker image ls`或者`docker images`命令。

  ​	列表包含了仓库名、标签、镜像ID、创建时间以及所占用的空间。

  - 镜像体积

    ​	如果仔细观察，会注意到，这里标识的所占用空间和在Docker Hub上看到的镜像大小不同。这是因为Docker Hub中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此Docker Hub所显示的大小是网络传输中更关心的流量大小。而`docker image ls`显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和。

    ​	另外一个需要注意的问题是，`docker image ls`列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于Docker镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于Docker使用UnionFS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。

    ​	可以使用`docker system df`命令查看镜像、容器、数据卷所占用的空间。

  - 虚悬镜像

    ​	有时候在镜像列表中，可以看到一些特殊的镜像，这些镜像既没有仓库名，也没有标签，均为`<none>`。

    ​	这些镜像原本是有镜像名的，例如原来为`mongo:3.2`，随着官方镜像维护，发布了新版本后，重新`docker pull mongo:3.2`时，`mongo:3.2`这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了`<none>`。除了`docker pull`可能导致这种情况，`docker build`也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为`<none>`的镜像。这类无标签的镜像也被称为虚悬镜像（dangling image），可以用下面的命令专门显示这类镜像：

    ```shell
    docker image ls -f dangling=true
    ```

    ​	一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。

    ```shell
    docker image prune
    ```

  - 中间层镜像

    ​	为了加速镜像构建、重复利用资源，Docker会利用中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的`docker image ls`列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加`-a`参数。

    ```shell
    docker image ls -a
    ```

    ​	这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其他镜像所依赖的镜像。这些无标签的镜像不应该被删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为他们被列出来而多存一份，无论如何你也会需要他们。只要删除那些依赖他们的镜像后，这些依赖的中间层镜像也会被连带删除。

  - 列出部分镜像

    - 根据仓库名列出镜像

      ```shell
      docker image ls ubuntu
      ```

    - 列出特定的某个镜像，也就是说指定仓库名和标签

      ```shell
      docker image ls ubuntu:16.04
      ```

    - 除此之外，`docker image ls`还支持强大的过滤器参数`--filter`，或者简写`-f`。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在`mongo:3.2`之后建立的镜像，可以用下面的命令：

      ```shell
      docker image ls -f since=mongo:3.2
      ```

      想查看某个位置之前的镜像也可以，只需要把`since`换成`before`即可。

      此外，如果镜像构建时，定义了`LABEL`，还可以通过`LABEL`来过滤。

      ```shell
      docker image ls -f label=com.example.version=0.1
      ```

    

- 删除本地镜像

  ​	如果要删除本地镜像，可以使用命令：

  ```shell
  docker image rm [选项] <镜像1> [<镜像2> ...]
  ```

  ​	其中，`镜像`可以是镜像短ID、镜像长ID、镜像名或者镜像摘要。

  Untagged和Deleted

  ​	如果观察删除命令的运行输出信息的话，你会注意到删除行为分为两类，一类是`untagged`，另一类是`deleted`。

  ​	镜像的唯一标识是其ID和摘要，而一个镜像可以有多个标签。因此当我们删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的`untagged`的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么`delete`行为就不会发生。

  ​	当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其他镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己pull时候看到的层数不一样的原因。

  ​	除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将他们删除，然后再来删除镜像。

